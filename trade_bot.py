# Hyperliquid Trade Execution Bot (trade.py)
#
# This script reads the 'trigger.json' file generated by the dashboard.
# If it detects a 'buy_signal', it executes a market buy order, logs the trade,
# and then resets the signal in the JSON file to prevent duplicate trades.
#
# To Run:
# 1. Ensure 'collector.py' and 'app.py' are running.
# 2. Configure your trade size in the 'TRADE_USD_SIZE' variable below.
# 3. Run this script from your terminal: python trade.py

import example_utils
from hyperliquid.utils import constants
import time
import json
import os
from datetime import datetime

# --- Configuration ---
TRIGGER_FILE = "trigger.json"  # CHANGED: Now reads from trigger.json instead of trade_signals.json
SIGNAL_FILE = "trade_signals.json"  # Keep for backward compatibility reset
TRADE_LOG_FILE = "trade_log.json"
CHECK_INTERVAL_SECONDS = 5  # Check the signal file every 5 seconds
TRADE_USD_SIZE = 225 # The size of the trade to place in USD

def read_trigger_file():
    """Reads the trigger data from the JSON file."""
    if not os.path.exists(TRIGGER_FILE):
        return None
    try:
        with open(TRIGGER_FILE, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        # Handle cases where the file is empty or being written to
        return None

def reset_all_signals():
    """Resets buy_signal and trigger states in all relevant files."""
    print("[*] Resetting all signal files to prevent duplicate trades...")
    
    # Reset trigger.json
    try:
        if os.path.exists(TRIGGER_FILE):
            with open(TRIGGER_FILE, 'r') as f:
                trigger_data = json.load(f)
            
            # Reset buy signal and trigger states
            trigger_data['buy_signal'] = False
            trigger_data['trigger_armed'] = False
            trigger_data['current_trigger_on'] = False
            
            with open(TRIGGER_FILE, 'w') as f:
                json.dump(trigger_data, f, indent=2)
            print(f"[*] Reset {TRIGGER_FILE}")
    except Exception as e:
        print(f"[!] Error resetting {TRIGGER_FILE}: {e}")
    
    # Reset trade_signals.json for backward compatibility
    try:
        if os.path.exists(SIGNAL_FILE):
            with open(SIGNAL_FILE, 'r') as f:
                signal_data = json.load(f)
            
            if 'state' in signal_data:
                signal_data['state']['buy_signal'] = False
                signal_data['state']['trigger_on'] = False
                
                with open(SIGNAL_FILE, 'w') as f:
                    json.dump(signal_data, f, indent=4)
                print(f"[*] Reset {SIGNAL_FILE}")
    except Exception as e:
        print(f"[!] Error resetting {SIGNAL_FILE}: {e}")
    
    print("[*] All signal files have been reset.")

def log_trade(trigger_data, order_result, order_size, trade_type):
    """Appends the details of a trade attempt to the trade log file."""
    print(f"[*] Logging '{trade_type}' trade attempt...")
    log_entry = {
        "log_timestamp": datetime.now().isoformat(),
        "trade_type": trade_type,
        "trade_size_usd": TRADE_USD_SIZE,
        "calculated_asset_size": order_size,
        "trigger_data": trigger_data,  # CHANGED: Now logs trigger data instead of signal data
        "exchange_response": order_result
    }
    
    # Read existing log data and append the new entry
    try:
        if os.path.exists(TRADE_LOG_FILE):
            with open(TRADE_LOG_FILE, 'r') as f:
                logs = json.load(f)
        else:
            logs = []
    except json.JSONDecodeError:
        logs = []

    logs.append(log_entry)

    # Write the updated log back to the file
    with open(TRADE_LOG_FILE, 'w') as f:
        json.dump(logs, f, indent=4)
    print("[*] Trade logged successfully.")

def main():
    """
    Main loop to check for signals and execute trades.
    """
    print("--- Hyperliquid Trading Bot ---")
    print("[*] Setting up connection...")
    
    # Setup connection to Hyperliquid
    address, info, exchange = example_utils.setup(constants.MAINNET_API_URL, skip_ws=True)
    print(f"[*] Successfully set up trading for address: {address}")
    print("[*] Bot is running. Scanning trigger.json for buy signals...")
    print("-" * 30)

    while True:
        try:
            # 1. Read the trigger file
            trigger_data = read_trigger_file()

            # CHANGED: Check for buy_signal in trigger data
            if trigger_data and trigger_data.get('buy_signal'):
                print(f"\n[!] BUY SIGNAL DETECTED at {trigger_data.get('timestamp')}")
                print(f"    Price: ${trigger_data.get('price', 0):.2f}")
                print(f"    Fib 0: ${trigger_data.get('wma_fib_0', 0):.2f}")
                print(f"    Fib Entry: ${trigger_data.get('fib_entry', 0):.2f}")
                print(f"    Trigger Armed: {trigger_data.get('trigger_armed')}")
                print(f"    In Buy Zone: {trigger_data.get('in_buy_zone')}")

                # --- Execute The Trade ---
                # Extract coin from trigger data (assuming it's stored there, or use default)
                coin = "SOL"  # You may want to store this in trigger.json or get it from elsewhere
                is_buy = True
                trade_type = "buy"

                meta = info.meta()
                sz_decimals = next((asset["szDecimals"] for asset in meta["universe"] if asset["name"] == coin), 2)

                market_price = float(info.all_mids()[coin])
                order_size_in_asset = round(TRADE_USD_SIZE / market_price, sz_decimals)
                
                print(f"[*] Placing market buy order for {order_size_in_asset} {coin}...")
                
                order_result = exchange.market_open(coin, is_buy, order_size_in_asset, None, 0.01)

                print("[*] Trade Result:")
                print(order_result)
                
                # 2. Log the trade attempt
                log_trade(trigger_data, order_result, order_size_in_asset, trade_type)
                
                # 3. Reset all signal files if the order was accepted by the exchange
                if order_result.get("status") == "ok":
                    reset_all_signals()
                else:
                    print("[!] ERROR: Order failed. Signal files will not be reset.")

                print("\n[*] Waiting for next signal...")

            time.sleep(CHECK_INTERVAL_SECONDS)

        except KeyboardInterrupt:
            print("\n[*] Bot stopped by user. Goodbye!")
            break
        except Exception as e:
            print(f"[!] An error occurred: {e}")
            time.sleep(CHECK_INTERVAL_SECONDS * 2)

if __name__ == "__main__":
    main()