# Hyperliquid Trade Execution Bot with Alerts (trade.py)
#
# This script reads the 'trigger.json' file generated by the dashboard.
# If it detects a 'buy_signal', it executes a market buy order, logs the trade,
# and then resets the signal in the JSON file to prevent duplicate trades.
#
# NEW: Includes hourly status updates to Discord to confirm the bot is running,
# in addition to real-time alerts for trigger states and buy signals.
#
# To Run:
# 1. Install the schedule library: pip install schedule
# 2. Ensure 'collector.py' and 'app.py' are running.
# 3. Configure your trade size in the 'TRADE_USD_SIZE' variable below.
# 4. Set up your Discord webhook URL.
# 5. Run this script from your terminal: python trade.py

import example_utils
from hyperliquid.utils import constants
import time
import json
import os
import requests
from datetime import datetime
import schedule # Import the schedule library

# --- Configuration ---
TRIGGER_FILE = "trigger.json"
SIGNAL_FILE = "trade_signals.json"  # Keep for backward compatibility reset
TRADE_LOG_FILE = "trade_log.json"
CHECK_INTERVAL_SECONDS = 5
TRADE_USD_SIZE = 225

# --- ALERT CONFIGURATION ---
DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1404935802810794004/VLu3___9gBvUv-UnoekLGW9ziln5RoMXq31Z40ovXXonFchRI00ADgt9yc3B0GY_YkVI"  # Add your Discord webhook URL here CHANGE MEEE
ENABLE_CONSOLE_ALERTS = True  # Always show alerts in console
ENABLE_DISCORD_ALERTS = bool(DISCORD_WEBHOOK_URL)  # Only if webhook is configured

# Alert state tracking to prevent spam
last_alert_states = {
    'trigger_armed': None,
    'buy_signal': None,
    'last_alert_time': None
}

def send_discord_alert(message, color=0x00ff00):
    """Send alert to Discord webhook"""
    if not DISCORD_WEBHOOK_URL:
        return
    
    try:
        embed = {
            "title": "ü§ñ SOL Trading Bot Alert",
            "description": message,
            "color": color,
            "timestamp": datetime.now().isoformat(),
            "footer": {"text": "Hyperliquid Trading Bot"}
        }
        
        payload = {"embeds": [embed]}
        
        response = requests.post(DISCORD_WEBHOOK_URL, json=payload, timeout=10)
        if response.status_code == 204:
            print("[‚úì] Discord alert sent successfully")
        else:
            print(f"[!] Discord alert failed: {response.status_code} - {response.text}")
    except Exception as e:
        print(f"[!] Discord alert error: {e}")

def send_alert(message, alert_type="info"):
    """Send alert via console and Discord"""
    global last_alert_states
    
    # Color coding for different alert types
    colors = {
        "trigger_armed": 0xffff00,      # Yellow
        "buy_signal": 0x00ff00,         # Green  
        "trade_executed": 0x0099ff,      # Bright Blue
        "error": 0xff0000,              # Red
        "info": 0x888888,               # Gray
        "status_update": 0x3498db       # Standard Blue
    }
    
    # Console alert
    if ENABLE_CONSOLE_ALERTS:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"\nüö® [{timestamp}] ALERT: {message}")
    
    # Discord alert
    if ENABLE_DISCORD_ALERTS:
        send_discord_alert(message, colors.get(alert_type, 0x888888))
    
    # Update last alert time
    last_alert_states['last_alert_time'] = datetime.now()

def send_hourly_status_update():
    """Sends a scheduled 'bot is running' status update."""
    print("[*] Sending hourly status update...")
    message = "‚úÖ Bot is alive and monitoring for signals."
    send_alert(message, "status_update")

def check_alert_conditions(trigger_data):
    """Check for alert conditions and send notifications for state changes."""
    global last_alert_states
    
    if not trigger_data:
        return
    
    current_trigger_armed = trigger_data.get('trigger_armed')
    current_buy_signal = trigger_data.get('buy_signal')
    current_price = trigger_data.get('price', 0)
    fib_0_level = trigger_data.get('wma_fib_0', 0)
    fib_entry_level = trigger_data.get('fib_entry', 0)
    
    # Alert when trigger gets ARMED (only once per state change)
    if current_trigger_armed and last_alert_states['trigger_armed'] is not True:
        message = f"üü° TRIGGER ARMED! Price: ${current_price:.2f} | Entry Level: ${fib_entry_level:.2f}"
        send_alert(message, "trigger_armed")
        last_alert_states['trigger_armed'] = True
    
    # Alert when trigger gets DISARMED (only once per state change)  
    elif not current_trigger_armed and last_alert_states['trigger_armed'] is not False:
        reset_threshold = fib_0_level * 1.005 if fib_0_level else 0
        message = f"üî¥ TRIGGER DISARMED. Price: ${current_price:.2f} is above reset threshold: ${reset_threshold:.2f}"
        send_alert(message, "info")
        last_alert_states['trigger_armed'] = False
    
    # Alert for BUY SIGNAL (only once per signal)
    if current_buy_signal and last_alert_states['buy_signal'] is not True:
        message = f"üöÄ BUY SIGNAL DETECTED! Price: ${current_price:.2f} | Fib 0: ${fib_0_level:.2f} | EXECUTING TRADE!"
        send_alert(message, "buy_signal")
        last_alert_states['buy_signal'] = True
    
    # Reset buy signal state when it goes false
    elif not current_buy_signal and last_alert_states['buy_signal'] is not False:
        last_alert_states['buy_signal'] = False

def read_trigger_file():
    """Reads the trigger data from the JSON file."""
    if not os.path.exists(TRIGGER_FILE):
        return None
    try:
        with open(TRIGGER_FILE, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return None

def reset_all_signals():
    """Resets buy_signal and trigger states in all relevant files."""
    print("[*] Resetting all signal files to prevent duplicate trades...")
    
    # Reset trigger.json
    try:
        if os.path.exists(TRIGGER_FILE):
            with open(TRIGGER_FILE, 'r') as f:
                trigger_data = json.load(f)
            
            trigger_data['buy_signal'] = False
            trigger_data['trigger_armed'] = False
            trigger_data['current_trigger_on'] = False
            
            with open(TRIGGER_FILE, 'w') as f:
                json.dump(trigger_data, f, indent=2)
            print(f"[*] Reset {TRIGGER_FILE}")
    except Exception as e:
        print(f"[!] Error resetting {TRIGGER_FILE}: {e}")
    
    # Reset trade_signals.json for backward compatibility
    try:
        if os.path.exists(SIGNAL_FILE):
            with open(SIGNAL_FILE, 'r') as f:
                signal_data = json.load(f)
            
            if 'state' in signal_data:
                signal_data['state']['buy_signal'] = False
                signal_data['state']['trigger_on'] = False
                
                with open(SIGNAL_FILE, 'w') as f:
                    json.dump(signal_data, f, indent=4)
                print(f"[*] Reset {SIGNAL_FILE}")
    except Exception as e:
        print(f"[!] Error resetting {SIGNAL_FILE}: {e}")
    
    print("[*] All signal files have been reset.")

def log_trade(trigger_data, order_result, order_size, trade_type):
    """Appends the details of a trade attempt to the trade log file."""
    print(f"[*] Logging '{trade_type}' trade attempt...")
    log_entry = {
        "log_timestamp": datetime.now().isoformat(),
        "trade_type": trade_type,
        "trade_size_usd": TRADE_USD_SIZE,
        "calculated_asset_size": order_size,
        "trigger_data": trigger_data,
        "exchange_response": order_result
    }
    
    try:
        if os.path.exists(TRADE_LOG_FILE):
            with open(TRADE_LOG_FILE, 'r') as f:
                logs = json.load(f)
        else:
            logs = []
    except json.JSONDecodeError:
        logs = []

    logs.append(log_entry)

    with open(TRADE_LOG_FILE, 'w') as f:
        json.dump(logs, f, indent=4)
    print("[*] Trade logged successfully.")

def main():
    """Main loop to check for signals and execute trades."""
    # --- NEW: Wrap entire main function in a try/except block to catch startup errors ---
    try:
        print("--- Hyperliquid Trading Bot with Alerts ---")
        print("[*] Setting up connection...")
        
        # Setup connection to Hyperliquid
        address, info, exchange = example_utils.setup(constants.MAINNET_API_URL, skip_ws=True)
        print(f"[*] Successfully set up trading for address: {address}")
        
        # Alert configuration status
        print(f"[*] Console Alerts: {'‚úì Enabled' if ENABLE_CONSOLE_ALERTS else '‚úó Disabled'}")
        print(f"[*] Discord Alerts: {'‚úì Enabled' if ENABLE_DISCORD_ALERTS else '‚úó Disabled (no webhook)'}")
        
        # Schedule the hourly status update
        print("[*] Scheduling hourly 'bot is alive' status update...")
        schedule.every().hour.at(":00").do(send_hourly_status_update)
        print("[*] Hourly update scheduled successfully.")
        
        print("[*] Bot is running. Scanning trigger.json for signals and alerts...")
        print("-" * 50)
        
        # Send startup alert
        send_alert("ü§ñ Trading bot started and monitoring for signals...", "info")

        while True:
            # Run any pending scheduled tasks
            schedule.run_pending()
            
            # Read the trigger file
            trigger_data = read_trigger_file()
            
            if trigger_data:
                # Check for alert conditions first (for state changes)
                check_alert_conditions(trigger_data)
                
                # Check for buy signal and execute trade
                if trigger_data.get('buy_signal'):
                    print(f"\n[!] EXECUTING BUY ORDER...")
                    print(f"    Price: ${trigger_data.get('price', 0):.2f}")
                    print(f"    Fib 0: ${trigger_data.get('wma_fib_0', 0):.2f}")
                    print(f"    Fib Entry: ${trigger_data.get('fib_entry', 0):.2f}")

                    # Execute The Trade
                    coin = "SOL"
                    is_buy = True
                    trade_type = "buy"

                    meta = info.meta()
                    sz_decimals = next((asset["szDecimals"] for asset in meta["universe"] if asset["name"] == coin), 2)

                    market_price = float(info.all_mids()[coin])
                    order_size_in_asset = round(TRADE_USD_SIZE / market_price, sz_decimals)
                    
                    print(f"[*] Placing market buy order for {order_size_in_asset} {coin}...")
                    
                    order_result = exchange.market_open(coin, is_buy, order_size_in_asset, None, 0.01)

                    print("[*] Trade Result:")
                    print(order_result)
                    
                    # Log the trade attempt
                    log_trade(trigger_data, order_result, order_size_in_asset, trade_type)
                    
                    # Send trade execution alert
                    if order_result.get("status") == "ok":
                        message = f"‚úÖ TRADE EXECUTED! Bought {order_size_in_asset} SOL at approx. ${market_price:.2f} | Total: ${TRADE_USD_SIZE}"
                        send_alert(message, "trade_executed")
                        reset_all_signals()
                    else:
                        message = f"‚ùå TRADE FAILED! Order rejected by exchange. Check logs for details."
                        send_alert(message, "error")
                        print("[!] ERROR: Order failed. Signal files will not be reset.")

                    print("\n[*] Waiting for next signal...")

            # Wait before the next check
            time.sleep(CHECK_INTERVAL_SECONDS)

    except KeyboardInterrupt:
        send_alert("üõë Trading bot stopped by user. Goodbye!", "info")
        print("\n[*] Bot stopped by user. Goodbye!")
    except Exception as e:
        # This will now catch errors during startup as well
        error_message = f"‚ùå A critical bot error occurred on startup or during runtime: {str(e)}"
        print(f"[!!!] CRITICAL ERROR: {e}")
        send_alert(error_message, "error")
        # Wait for a moment to ensure the alert can be sent before the script exits
        time.sleep(5)


if __name__ == "__main__":
    main()
